\;     \n\;     \n:global globalNoteMe;\;     \n:if (!any \$globalNoteMe) do={\;     \n\;     \n  :global globalNoteMe do={\;     \n\;     \n  :local scriptname [:jobname] ;\;     \n  ## outputs \$value using both :put and :log info\;     \n  ## example \$outputInfo value=\"12345\"\;     \n\;     \n  :local state \"\$scriptname: \$value\";\;     \n  :put \"\$state\"\;     \n  :log info \"\$state\"\;     \n\;     \n  }\;     \n}\;     \n\;     \n\;     \n:global globalScriptBeforeRun;\;     \n:if (!any \$globalScriptBeforeRun) do={\;     \n  :global globalScriptBeforeRun do={\;     \n\;     \n    :global globalNoteMe;\;     \n    :if ([:len \$1] > 0) do={\;     \n\;     \n           :local scriptname [:jobname] ;\;     \n           :local state \"\$scriptname instance already running - prevent new instance\";\;     \n\;     \n           :if ([/system script job print count-only as-value where script=\$scriptname] > 1) do={\;     \n              :log error \$state\;     \n               \$globalNoteMe value=\$state;\;     \n               :error \$state\;     \n            }\;     \n\;     \n      :local state \"Starting script: \$scriptname\";\;     \n      \$globalNoteMe value=\$state;\;     \n\;     \n    }\;     \n  }\;     \n}\;     \n\;     \n### \$SECRET\;     \n#   get <name>\;     \n#   set <name> password=<password>\;     \n# . remove <name\;     \n#   print\;     \n:if (!any \$SECRET) do={\;     \n:global SECRET do={\;     \n\;     \n    # helpers\;     \n    :local fixprofile do={\;     \n        :if ([/ppp profile find name=\"null\"]) do={:put \"nothing\"} else={\;     \n            /ppp profile add bridge-learning=no change-tcp-mss=no local-address=0.0.0.0 name=\"null\" only-one=yes remote-address=0.0.0.0 session-timeout=1s use-compression=no use-encryption=no use-mpls=no use-upnp=no\;     \n        }\;     \n    }\;     \n    :local lppp [:len [/ppp secret find where name=\$2]]\;     \n    :local checkexist do={\;     \n        :if (lppp=0) do={\;     \n            :error \"\\\$SECRET: cannot find \$2 in secret store\"\;     \n        }\;     \n    }\;     \n\;     \n    # \$SECRET\;     \n    :if ([:typeof \$1]!=\"str\") do={\;     \n        :put \"\\\$SECRET\"\;     \n        :put \"   uses /ppp/secrets to store stuff like REST apikeys, or other sensative data\"\;     \n        :put \"\\t\\\$SECRET print - prints stored secret passwords\"\;     \n        :put \"\\t\\\$SECRET get <name> - gets a stored secret\"\;     \n        :put \"\\t\\\$SECRET set <name> password=\\\"YOUR_SECRET\\\" - sets a secret password\" \;     \n        :put \"\\t\\\$SECRET remove <name> - removes a secret\" \;     \n    }\;     \n\;     \n    # \$SECRET print\;     \n    :if (\$1~\"^pr\") do={\;     \n        /ppp secret print where comment~\"\\\\\\\$SECRET\"\;     \n        :return [:nothing] \;     \n    }\;     \n\;     \n    # \$SECRET get\;     \n    :if (\$1~\"get\") do={\;     \n        \$checkexist\;     \n       :return [/ppp secret get \$2 password] \;     \n    }\;     \n\;     \n    # \$SECRET set\;     \n    :if (\$1~\"set|add\") do={\;     \n        :if ([:typeof \$password]=\"str\") do={} else={:error \"\\\$SECRET: password= required\"}\;     \n        :if (lppp=0) do={\;     \n            /ppp secret add name=\$2 password=\$password \;     \n        } else={\;     \n            /ppp secret set \$2 password=\$password\;     \n        }\;     \n        \$fixprofile\;     \n        /ppp secret set \$2 comment=\"used by \\\$SECRET\"\;     \n        /ppp secret set \$2 profile=\"null\"\;     \n        /ppp secret set \$2 service=\"async\"\;     \n        :return [\$SECRET get \$2]\;     \n    } \;     \n\;     \n    # \$SECRET remove\;     \n    :if (\$1~\"rm|rem|del\") do={\;     \n        \$checkexist\;     \n        :return [/ppp secret remove \$2]\;     \n    }\;     \n    :error \"\\\$SECRET: bad command\"\;     \n}\;     \n}\;     \n\;     \n\;     \n:global globalTgMessage;\;     \n:if (!any \$globalTgMessage) do={\;     \n  :global globalTgMessage do={\;     \n\;     \n    :global globalNoteMe;\;     \n    :global SECRET;\;     \n\;     \n    \$SECRET set TELEGRAM_TOKEN password=\"798290125:AAE3gfeLKdtai3RPtnHRLbE8quNgAh7iC8M\";\;     \n    \$SECRET set TELEGRAM_CHAT_ID password=\"-1001798127067\";\;     \n\;     \n    :local tToken \"\$[\$SECRET get TELEGRAM_TOKEN]\";\;     \n    :local tGroupID \"\$[\$SECRET get TELEGRAM_CHAT_ID]\";\;     \n    :local tURL \"https://api.telegram.org/bot\$tToken/sendMessage\\\?chat_id=\$tGroupID\";\;     \n\;     \n    :local sysname (\"#\" . [/system identity get name]);\;     \n    :local scriptname [:jobname] ;\;     \n\;     \n    :local tgmessage  (\"\$scriptname %C2%A9%EF%B8%8F \$sysname: \$value\");  \;     \n\;     \n    :local state (\"Sending telegram message... \$tgmessage\");\;     \n    \$globalNoteMe value=\$tgmessage;\;     \n\;     \n    :do {\;     \n      /tool fetch http-method=post mode=https url=\"\$tURL\" http-data=\"text=\$tgmessage\" keep-result=no;\;     \n    } on-error= {\;     \n      :local state (\"Telegram notify error\");\;     \n      \$globalNoteMe value=\$state;\;     \n    };\;     \n  }\;     \n}\;     \n\;     \n:global globalIPSECPolicyUpdateViaSSH;\;     \n:if (!any \$globalIPSECPolicyUpdateViaSSH) do={\;     \n  :global globalIPSECPolicyUpdateViaSSH do={\;     \n\;     \n    :global globalRemoteIp;\;     \n    :global globalNoteMe;\;     \n\;     \n    :if ([:len \$1] > 0) do={\;     \n      :global globalRemoteIp (\"\$1\" . \"/32\");\;     \n    }\;     \n\;     \n    :if (!any \$globalRemoteIp) do={\;     \n      :global globalRemoteIp \"0.0.0.0/32\"\;     \n    } else={\;     \n    }\;     \n\;     \n    :local state (\"RPC... \$value\");\;     \n    \$globalNoteMe value=\$state;\;     \n    :local count [:len [/system script find name=\"doUpdatePoliciesRemotely\"]];\;     \n    :if (\$count > 0) do={\;     \n       :local state (\"Starting policies process... \$globalRemoteIp \");\;     \n       \$globalNoteMe value=\$state;\;     \n       /system script run doUpdatePoliciesRemotely;\;     \n     }\;     \n  }\;     \n}\;     \n\;     \n#Example call\;     \n#\$globalNewNetworkMember ip=192.168.90.130 mac=50:DE:06:25:C2:FC gip=192.168.98.130 comm=iPadAlxPro ssid=\"WiFi 5\"\;     \n:global globalNewNetworkMember;\;     \n:if (!any \$globalNewNetworkMember) do={\;     \n  :global globalNewNetworkMember do={\;     \n\;     \n    :global globalNoteMe;\;     \n\;     \n    #to prevent connection\;     \n    :local guestDHCP \"guest-dhcp-server\";\;     \n\;     \n    #to allow connection\;     \n    :local mainDHCP \"main-dhcp-server\";\;     \n\;     \n    #when DHCP not using (add arp for leases)\;     \n    :local arpInterface \"main-infrastructure-br\";\;     \n    :local state (\"Adding new network member... \");\;     \n\;     \n    \$globalNoteMe value=\$state;\;     \n\;     \n    # incoming named params\;     \n    :local newIp [ :tostr \$ip ];\;     \n    :local newBlockedIp [ :tostr \$gip ];\;     \n    :local newMac [ :tostr \$mac ];\;     \n    :local comment [ :tostr \$comm ];\;     \n    :local newSsid [ :tostr \$ssid ];\;     \n    :if ([:len \$newIp] > 0) do={\;     \n        :if ([ :typeof [ :toip \$newIp ] ] != \"ip\" ) do={\;     \n\;     \n            :local state (\"Error: bad IP parameter passed - (\$newIp)\");\;     \n            \$globalNoteMe value=\$state;\;     \n            :return false;\;     \n\;     \n        }\;     \n    } else={\;     \n\;     \n        :local state (\"Error: bad IP parameter passed - (\$newIp)\");\;     \n        \$globalNoteMe value=\$state;\;     \n        :return false;\;     \n\;     \n    }\;     \n\;     \n    :do {\;     \n\;     \n        :local state (\"Removing existing DHCP configuration for (\$newIp/\$newMac) on \$mainDHCP\");\;     \n        \$globalNoteMe value=\$state;       \;     \n        /ip dhcp-server lease remove [find address=\$newIp];\;     \n        /ip dhcp-server lease remove [find mac-address=\$newMac];\;     \n\;     \n        :local state (\"Adding DHCP configuration for (\$newIp/\$newMac) on \$mainDHCP\");\;     \n        \$globalNoteMe value=\$state;\;     \n        \;     \n       :if ([ :len [ /ip dhcp-server find where name=\"\$mainDHCP\" ] ] > 0) do={\;     \n            /ip dhcp-server lease add address=\$newIp mac-address=\$newMac server=\$mainDHCP comment=\$comment;\;     \n            :local state (\"Done.\");\;     \n            \$globalNoteMe value=\$state;\;     \n       } else={\;     \n        :local state (\"Cant find DHCP server \$mainDHCP. SKIPPED.\");\;     \n        \$globalNoteMe value=\$state;\;     \n       }\;     \n\;     \n    } on-error={\;     \n\;     \n        :local state (\"Error: something fail on DHCP configuration 'allow' step for (\$newIp/\$newMac) on \$mainDHCP\");\;     \n        \$globalNoteMe value=\$state;\;     \n        :return false;\;     \n\;     \n    }\;     \n\;     \n    :do {\;     \n\;     \n        /ip dhcp-server lease remove [find address=\$newBlockedIp];\;     \n        :local state (\"Adding DHCP configuration for (\$newBlockedIp/\$newMac) on \$guestDHCP (preventing connections to guest network)\");\;     \n        \$globalNoteMe value=\$state;\;     \n\;     \n       :if ([ :len [ /ip dhcp-server find where name=\"\$guestDHCP\" ] ] > 0) do={\;     \n          /ip dhcp-server lease add address=\$newBlockedIp block-access=yes mac-address=\$newMac server=\$guestDHCP comment=(\$comment . \"(blocked)\");\;     \n          :local state (\"Done.\");\;     \n          \$globalNoteMe value=\$state;\;     \n       } else={\;     \n        :local state (\"Cant find DHCP server \$guestDHCP. SKIPPED.\");\;     \n        \$globalNoteMe value=\$state;\;     \n       }\;     \n\;     \n    } on-error={\;     \n\;     \n        :local state (\"Error: something fail on DHCP configuration 'block' step for (\$newBlockedIp/\$newMac) on \$guestDHCP\");\;     \n        \$globalNoteMe value=\$state;\;     \n        :return false;\;     \n\;     \n    }\;     \n\;     \n    :do {\;     \n\;     \n        :local state (\"Adding ARP static entries for (\$newBlockedIp/\$newMac) on \$mainDHCP\");\;     \n        \$globalNoteMe value=\$state;\;     \n        /ip arp remove [find address=\$newIp];\;     \n        /ip arp remove [find address=\$newBlockedIp];\;     \n        /ip arp remove [find mac-address=\$newMac];\;     \n\;     \n     :if ([ :len [ /interface find where name=\"\$arpInterface\" ] ] > 0) do={\;     \n        /ip arp add address=\$newIp interface=\$arpInterface mac-address=\$newMac comment=\$comment\;     \n        :local state (\"Done.\");\;     \n        \$globalNoteMe value=\$state;\;     \n       } else={\;     \n        :local state (\"Cant find interface \$arpInterface. SKIPPED.\");\;     \n        \$globalNoteMe value=\$state;\;     \n       }\;     \n\;     \n    } on-error={\;     \n\;     \n        :local state (\"Error: something fail on ARP configuration step\");\;     \n        \$globalNoteMe value=\$state;\;     \n        :return false;\;     \n\;     \n    }\;     \n\;     \n    :do {\;     \n\;     \n        :local state (\"Adding CAPs ACL static entries for (\$newBlockedIp/\$newMac) on \$newSsid\");\;     \n        \$globalNoteMe value=\$state;\;     \n        \;     \n         # avoid parce errors using Execute when no wireless package installed\;     \n       :if ( [ :len [ /system package find where name=\"wireless\" and disabled=no ] ] > 0  ) do={\;     \n          :local Cmd \"/caps-man access-list remove [find mac-address=\$newMac];\";\;     \n          :local jobid [:execute script=\$Cmd];\;     \n\;     \n          :local Cmd \"/caps-man access-list add action=accept allow-signal-out-of-range=10s client-to-client-forwarding=yes comment=\$comment disabled=no mac-address=\$newMac ssid-regexp='\$newSsid' place-before=1;\";\;     \n          :local jobid [:execute script=\$Cmd];\;     \n\;     \n          }\;     \n\;     \n    } on-error={\;     \n\;     \n        :local state (\"Error: something fail on CAPS configuration step\");\;     \n        \$globalNoteMe value=\$state;\;     \n        :return false;\;     \n\;     \n    }\;     \n\;     \n    :return true;\;     \n\;     \n  }\;     \n}\;     \n\;     \n\;     \n\;     \n#Example call\;     \n#\$globalNewClientCert argClients=\"anna.ipsec, mikrouter.ipsec\" argUsage=\"tls-client,digital-signature,key-encipherment\"\;     \n#\$globalNewClientCert argClients=\"anna.capsman, mikrouter.capsman\" argUsage=\"digital-signature,key-encipherment\"\;     \n#\$globalNewClientCert argClients=\"185.13.148.14\" argUsage=\"tls-server\" argBindAsIP=\"any\"\;     \n:if (!any \$globalNewClientCert) do={\;     \n  :global globalNewClientCert do={\;     \n\;     \n    # generates IPSEC certs CLIENT TEMPLATE, then requests SCEP to sign it\;     \n    # This script is a SCEP-client, it request the server to provide a new certificate\;     \n    # it ONLY form the request via API to remote SCEP server\;     \n\;     \n    # incoming named params\;     \n    :local clients [ :tostr \$argClients ];\;     \n    :local prefs  [ :tostr \$argUsage ];\;     \n    :local asIp  \$argBindAsIP ;\;     \n\;     \n    # scope global functions\;     \n    :global globalNoteMe;\;     \n    :global globalScriptBeforeRun;\;     \n\;     \n    :if ([:len \$clients] > 0) do={\;     \n      :if ([ :typeof [ :tostr \$clients ] ] != \"str\" ) do={\;     \n\;     \n          :local state (\"Error: bad 'cients' parameter passed - (\$clients)\");\;     \n          \$globalNoteMe value=\$state;\;     \n          :return false;\;     \n\;     \n      }\;     \n    } else={\;     \n\;     \n        :local state (\"Error: bad 'cients' parameter passed - (\$clients\");\;     \n        \$globalNoteMe value=\$state;\;     \n        :return false;\;     \n\;     \n    }\;     \n\;     \n    :do {\;     \n\;     \n      #clients\;     \n      :local IDs [:toarray \"\$clients\"];\;     \n      :local fakeDomain \"myvpn.fake.org\"\;     \n      :local scepAlias \"CHR\"\;     \n      :local state (\"Started requests generation\");\;     \n\;     \n      \$globalNoteMe value=\$state;\;     \n\;     \n      ## this fields should be empty IPSEC/ike2/RSA to work, i can't get it functional with filled fields\;     \n      :local COUNTRY \"RU\"\;     \n      :local STATE \"MSC\"\;     \n      :local LOC \"Moscow\"\;     \n      :local ORG \"IKEv2 Home\"\;     \n      :local OU \"IKEv2 Mikrotik\"\;     \n\;     \n      # :local COUNTRY \"\"\;     \n      # :local STATE \"\"\;     \n      # :local LOC \"\"\;     \n      # :local ORG \"\"\;     \n      # :local OU \"\"\;     \n\;     \n\;     \n      :local KEYSIZE \"2048\"\;     \n\;     \n      :local scepUrl \"http://185.13.148.14/scep/grant\";\;     \n      :local itsOk true;\;     \n\;     \n      :local tname \"\";\;     \n      :foreach USERNAME in=\$IDs do={\;     \n\;     \n        ## create a client certificate (that will be just a template while not signed)\;     \n        :if (  [:len \$asIp ] > 0 ) do={\;     \n\;     \n                :local state \"CLIENT TEMPLATE certificates generation as IP...  \$USERNAME\";\;     \n                \$globalNoteMe value=\$state;\;     \n\;     \n                :set tname \"S.\$USERNAME@\$scepAlias\";\;     \n\;     \n                :if ([ :len [ /certificate find where name=\"\$tname\" ] ] > 0) do={\;     \n\;     \n                  :local state (\"Error: found certificate named (\$tname) -  cannot create the same one\");\;     \n                  \$globalNoteMe value=\$state;\;     \n                  :return false;\;     \n\;     \n                } else={\;     \n\;     \n                  /certificate add name=\"\$tname\" common-name=\"\$USERNAME@\$scepAlias\" subject-alt-name=\"IP:\$USERNAME,DNS:\$fakeDomain\" key-usage=\$prefs country=\"\$COUNTRY\" state=\"\$STATE\" locality=\"\$LOC\" organization=\"\$ORG\" unit=\"\$OU\"  key-size=\"\$KEYSIZE\" days-valid=365;\;     \n\;     \n                };\;     \n\;     \n            } else={\;     \n\;     \n                :local state \"CLIENT TEMPLATE certificates generation as EMAIL...  \$USERNAME\";\;     \n                \$globalNoteMe value=\$state;\;     \n\;     \n                :set tname \"C.\$USERNAME@\$scepAlias\";\;     \n\;     \n                :if ([ :len [ /certificate find where name=\"\$tname\" ] ] > 0) do={\;     \n\;     \n                  :local state (\"Error: found certificate named (\$tname) -  cannot create the same one\");\;     \n                  \$globalNoteMe value=\$state;\;     \n                  :return false;\;     \n\;     \n                } else={\;     \n\;     \n                  /certificate add name=\"\$tname\" common-name=\"\$USERNAME@\$scepAlias\" subject-alt-name=\"email:\$USERNAME@\$fakeDomain\" key-usage=\$prefs  country=\"\$COUNTRY\" state=\"\$STATE\" locality=\"\$LOC\" organization=\"\$ORG\" unit=\"\$OU\"  key-size=\"\$KEYSIZE\" days-valid=365\;     \n\;     \n                };\;     \n\;     \n            }\;     \n\;     \n        :local state \"Pushing sign request...\";\;     \n        \$globalNoteMe value=\$state;\;     \n        /certificate add-scep template=\"\$tname\" scep-url=\"\$scepUrl\";\;     \n\;     \n        :delay 6s\;     \n\;     \n        ## we now have to wait while on remote [mikrotik] this request will be granted and pushed back ready-to-use certificate\;     \n        :local state \"We now have to wait while on remote [mikrotik] this request will be granted and pushed back ready-to-use certificate... \";\;     \n        \$globalNoteMe value=\$state;\;     \n\;     \n        :local state \"Proceed to remote SCEP please, find this request and appove it. I'll wait 30 seconds\";\;     \n        \$globalNoteMe value=\$state;\;     \n\;     \n        :delay 30s\;     \n\;     \n        :local baseLength 5;\;     \n        :for j from=1 to=\$baseLength do={\;     \n          :if ([ :len [ /certificate find where status=\"idle\" name=\"\$tname\" ] ] > 0) do={\;     \n\;     \n            :local state \"Got it at last. Exporting to file\";\;     \n            \$globalNoteMe value=\$state;\;     \n\;     \n            /certificate set trusted=yes [find where name=\"\$tname\" and status=\"idle\"]\;     \n\;     \n            ## export the CA, client certificate, and private key\;     \n            /certificate export-certificate [find where name=\"\$tname\" and status=\"idle\"] export-passphrase=\"1234567890\" type=pkcs12\;     \n\;     \n            :return true;\;     \n\;     \n          } else={\;     \n\;     \n            :local state \"Waiting for mikrotik to download the certificate...\";\;     \n            \$globalNoteMe value=\$state;\;     \n            :delay 8s\;     \n\;     \n          };\;     \n        }\;     \n      };\;     \n\;     \n      :return false;\;     \n\;     \n    } on-error={\;     \n\;     \n        :local state (\"Error: something fail on SCEP certifcates issuing step\");\;     \n        \$globalNoteMe value=\$state;\;     \n        :return false;\;     \n\;     \n    }\;     \n  }\;     \n}\;     \n\;     \n\;     \n\;     \n:if (!any \$globalCallFetch) do={\;     \n  :global globalCallFetch do={\;     \n\;     \n    # this one calls Fetch and catches its errors\;     \n    :global globalNoteMe;\;     \n    :if ([:len \$1] > 0) do={\;     \n\;     \n        # something like \"/tool fetch address=nas.home port=21 src-path=scripts/doSwitchDoHOn.rsc.txt user=git password=git dst-path=/REPO/doSwitchDoHOn.rsc.txt mode=ftp upload=yes\"\;     \n        :local fetchCmd \"\$1\";\;     \n\;     \n        :local state \"I'm now putting: \$fetchCmd\";\;     \n        \$globalNoteMe value=\$state;\;     \n\;     \n        /file remove [find where name=\"fetch.log.txt\"]\;     \n        {\;     \n            :local jobid [:execute file=fetch.log.txt script=\$fetchCmd]\;     \n\;     \n            :local state \"Waiting the end of process for file fetch.log to be ready, max 20 seconds...\";\;     \n            \$globalNoteMe value=\$state;\;     \n\;     \n            :global Gltesec 0\;     \n            :while (([:len [/sys script job find where .id=\$jobid]] = 1) && (\$Gltesec < 20)) do={\;     \n                :set Gltesec (\$Gltesec + 1)\;     \n                :delay 1s\;     \n\;     \n                :local state \"waiting... \$Gltesec\";\;     \n                \$globalNoteMe value=\$state;\;     \n\;     \n            }\;     \n\;     \n            :local state \"Done. Elapsed Seconds: \$Gltesec\\r\\n\";\;     \n            \$globalNoteMe value=\$state;\;     \n\;     \n            :if ([:len [/file find where name=\"fetch.log.txt\"]] = 1) do={\;     \n                :local filecontent [/file get [/file find where name=\"fetch.log.txt\"] contents]\;     \n                :put \"Result of Fetch:\\r\\n****************************\\r\\n\$filecontent\\r\\n****************************\"\;     \n                /file remove [find where name=\"fetch.log.txt\"]\;     \n            } else={\;     \n                :put \"File not created.\"\;     \n            }\;     \n        }\;     \n    }\;     \n  }\;     \n}\;     \n\;     \n#:put [\$simplercurrdatetimestr]\;     \n:if (!any \$simplercurrdatetimestr) do={\;     \n:global simplercurrdatetimestr do={\;     \n    /system clock\;     \n    :local vdate [get date]\;     \n    :local vtime [get time]\;     \n    :local vdoff [:toarray \"0,4,5,7,8,10\"]\;     \n    :local MM    [:pick \$vdate (\$vdoff->2) (\$vdoff->3)]\;     \n    :local M     [:tonum \$MM]\;     \n    :if (\$vdate ~ \".../../....\") do={\;     \n        :set vdoff [:toarray \"7,11,1,3,4,6\"]\;     \n        :set M     ([:find \"xxanebarprayunulugepctovecANEBARPRAYUNULUGEPCTOVEC\" [:pick \$vdate (\$vdoff->2) (\$vdoff->3)] -1] / 2)\;     \n        :if (\$M>12) do={:set M (\$M - 12)}\;     \n        :set MM    [:pick (100 + \$M) 1 3]\;     \n    }\;     \n    :local yyyy [:pick \$vdate (\$vdoff->0) (\$vdoff->1)]\;     \n    :local dd   [:pick \$vdate (\$vdoff->4) (\$vdoff->5)]\;     \n    :local HH   [:pick \$vtime 0  2]\;     \n    :local mm   [:pick \$vtime 3  5]\;     \n    :local ss   [:pick \$vtime 6  8]\;     \n\;     \n    :return \"\$yyyy\$MM\$dd-\$HH\$mm\$ss\"\;     \n}\;     \n\;     \n}\;     \n\;     \n\;     \n#Example call\;     \n#:put [\$globalOnPrimaryPartition]\;     \n#test if we are boot up from a primary partition(not fallback or recovery)\;     \n:global globalOnPrimaryPartition;\;     \n:if (!any \$globalOnPrimaryPartition) do={\;     \n    :global globalOnPrimaryPartition do={\;     \n        \;     \n        :global globalNoteMe;\;     \n            # \;     \n        :local partitionName \"primary\";\;     \n        :local OnPrimaryPartition false;\;     \n        \;     \n        :onerror errorName in={ \;     \n            \;     \n            # test if it exist in /partitions\;     \n            :local partition [/partitions find name=\$partitionName];\;     \n            :if ([:len \$partition] > 0) do={\;     \n                :local running [/partition get \$partition running];\;     \n                :if (\$running) do={\;     \n                    :set OnPrimaryPartition true;\;     \n                    :error \"primary active\";\;     \n                } else={\;     \n                    :set OnPrimaryPartition false;\;     \n                    :error \"primary inactive\";\;     \n                }\;     \n            } else={\;     \n                :set OnPrimaryPartition true;\;     \n                :error \"disabled\";\;     \n            }\;     \n\;     \n        } do={ \;     \n\;     \n            :local state (\"Investigation result - \$errorName\");\;     \n            \$globalNoteMe value=\$state;\;     \n\;     \n            :return \$OnPrimaryPartition;\;     \n        }\;     \n       \;     \n        :put \$OnPrimaryPartition \;     \n        :return \$OnPrimaryPartition;\;     \n    }\;     \n\;     \n}\;     \n\;     \n\;     \n\;     \n\;     \n
