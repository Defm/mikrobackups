#------------------------------------------------------------------------------------------------------------------------
# SATELLITE1ext module  for TLGRM version 1.8 by Sertik (Serkov S.V.) 24/04/2022
#------------------------------------------------------------------------------------------------------------------------

# declare functions:

:global FuncHealth


# health Router ->Telegram
# ---------------------------------------

:set FuncHealth do={
:if ([:len $0]!=0) do={

# Script view health of device by Enternight
# https://forummikrotik.ru/viewtopic.php?t=7924
# tested on ROS 6.49.5
# updated 2022/04/21

:global Emoji
:global FuncTelegramSender

:do {
    :local hddTotal [/system resource get total-hdd-spac];
    :local hddFree  [/system resource get free-hdd-space];
   :local badBlock [/system resource get bad-blocks    ];
    :local memTotal [/system resource get total-memory  ];
    :local memFree  [/system resource get free-memory   ];
    :local cpuA     [/system resource get cpu];
    :local arhA      [/system resource get arch];
    :local cpuZ     [/system resource get cpu-load      ];
    :local currFW   [/system routerbo get upgrade-firmwa];
    :local upgrFW   [/system routerbo get current-firmwa];
    :if ([/system resource get board-name]!="CHR") do={
         :local tempC    [/system health   get temperature   ];
         :local volt     [/system health   get voltage       ];
          }
    :local smplVolt ($volt/10);
    :local lowVolt  (($volt-($smplVolt*10))*10);
    :local inVolt   ("$smplVolt.$[:pick $lowVolt 0 3]");
    :set   hddFree  ($hddFree/($hddTotal/100));
    :set   memFree  ($memFree/($memTotal/100));
    :local message  ("$Emoji $[system identity get name] Health report:");
    :set   message  ("$message %0AModel $[system resource get board-name]");
    :set   message  ("$message %0ACPU $cpuA");
    :set   message  ("$message %0Aarchitecture $arhA");
    :set   message  ("$message %0AROS v.$[system resource get version]");
    :if ($currFW != $upgrFW) do={set message ("$message %0A*FW is not updated*")}
    :set   message  ("$message %0AUptime $[system resource get uptime]");
    :if ($cpuZ < 90) do={:set message ("$message %0ACPU load $cpuZ%");
    } else={:set message ("$message %0A*Large CPU usage $cpuZ%*")}
    :if ($memFree > 17) do={:set message ("$message %0AMem free $memFree%");
    } else={:set message ("$message %0A*Low free mem $memFree%*")}
    :if ($hddFree > 6) do={:set message ("$message %0AHDD free $hddFree%");
    } else={:set message ("$message %0A*Low free HDD $hddFree%*")}
    :if ([:len $badBlock] > 0) do={
        :if ($badBlock = 0) do={:set message ("$message %0ABad blocks $badBlock%");
        } else={:set message ("$message %0A*Present bad blocks $badBlock%*")} }
    :if ([:len $volt] > 0) do={
        :if ($smplVolt > 4 && $smplVolt < 50) do={:set message ("$message %0AVoltage $inVolt V");
        } else={:set message ("$message %0A*Bad voltage $inVolt V*")} }
    :if ([:len $tempC] > 0) do={
        :if ($tempC > 10 && $tempC < 40) do={:set message ("$message %0ATemp $tempC C");
        } else={:set message ("$message %0A*Abnorm temp $tempC C*")} }

    :local gwList [:toarray ""];
    :local count 0;
    :local routeISP [/ip route find dst-address=0.0.0.0/0];
    :if ([:len $routeISP] > 0) do={

        # Listing all gateways
        :foreach inetGate in=$routeISP do={
            :local gwStatus [:tostr [/ip route get $inetGate gateway-status]];
            :if (([:len [:find $gwStatus "unreachable"]]=0) && ([:len [:find $gwStatus "inactive"]]=0)) do={

                # Formation of interface name
                :local ifaceISP "";
                :foreach idName in=[/interface find] do={
                    :local ifName [/interface get $idName name];
                    :if ([:len [find key=$ifName in=$gwStatus]] > 0) do={:set ifaceISP $ifName}
                }
                :if ([:len $ifaceISP] > 0) do={

                    # Checking the interface for entering the Bridge
                    :if ([:len [/interface bridge find name=$ifaceISP]] > 0) do={
#                        :local ipAddrGate [:pick $gwStatus 0 ([:find $gwStatus "reachable"] -1)];
                        :local ipAddrGate [:tostr [/ip route get $inetGate gateway]];
                        :if ([:find $ipAddrGate "%"] > 0) do={
                            :set $ipAddrGate [:pick $ipAddrGate ([:len [:pick $ipAddrGate 0 [:find $ipAddrGate "%"]] ] +1) [:len $ipAddrGate]];
                        }
                        :if ($ipAddrGate~"[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}") do={
                            :local mcAddrGate [/ip arp get [find address=$ipAddrGate interface=$ifaceISP] mac-address];
                            :if ($mcAddrGate~"[0-F][0-F]:[0-F][0-F]:[0-F][0-F]:[0-F][0-F]:[0-F][0-F]:[0-F][0-F]") do={
                               :set ifaceISP [/interface bridge host get [find mac-address=$mcAddrGate] interface];
                           } else={:set ifaceISP ""}
                       } else={:set ifaceISP ""}
                    }
                    :if ([:len $ifaceISP] > 0) do={

                        # Checking the repetition of interface name
                        :if ([:len [find key=$ifaceISP in=$gwList]] = 0) do={
                            :set ($gwList->$count) $ifaceISP;
                            :set count ($count+1);
                            :local rxByte [/interface get $ifaceISP rx-byte];
                            :local txByte [/interface get $ifaceISP tx-byte];
                            :local simpleGbRxReport ($rxByte/1073741824);
                            :local simpleGbTxReport ($txByte/1073741824);
                            :local lowGbRxReport ((($rxByte-($simpleGbRxReport*1073741824))*1000000000)/1048576);
                            :local lowGbTxReport ((($txByte-($simpleGbTxReport*1073741824))*1000000000)/1048576);
                            :local gbRxReport ("$simpleGbRxReport.$[:pick $lowGbRxReport 0 2]");
                            :local gbTxReport ("$simpleGbTxReport.$[:pick $lowGbTxReport 0 2]");
                            :set message ("$message %0ATraffic via '$ifaceISP' Rx/Tx $gbRxReport/$gbTxReport Gb");
                        }
                    }
                }
            }
        }
    } else={:set message ("$message %0AWAN iface not found")}

    :if ([/ppp active find]) do={
   :foreach i in=[/ppp active find] do={
   :set $name [/ppp active get $i name]; :set $type [/ppp active get $i service]; :set $enc [/ppp active get $i encoding]; :set $addr [/ppp active get $i address]; :set $ltu [/ppp active get $i uptime]
   :set $vpnuser ("$vpnuser"."$name"." {"."$type"."}"." $addr"." uptime: "."$ltu"."%0A");}
   :set $message ("$message"."%0A"."$vpnuser")
   } else={:set message ("$message %0ANo active VPN-channels")}
   [$FuncTelegramSender $message]
   :return []
} on-error={:log warning ("Error, can't show health status"); :return "ERROR"}
 }
}

:log info "  -    SATELLITE1ext module is set"
